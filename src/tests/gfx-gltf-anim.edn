(def timestep (/ 1.0 120.0))
(defmesh root)

(defshards get-view-transform [time]
  (Float4 0.0 1.0 -5.0 1.0) >= .arm-pos
  time (Math.AxisAngleY) (Math.Rotation) (Math.MatMul .arm-pos) (ToFloat3) >= .arm-pos-3
  {:Position .arm-pos-3 :Target (Float3 0 0.025 0)} (Math.LookAt))

(defshards get-xy-wave-transform [x time]
  time (Math.Multiply 4.5) (Math.Cos) (Math.Multiply 0.01) >= .tmp-y
  [x .tmp-y 0] (ToFloat3) (Math.Translation))

(defloop character
  (Take "Position") = .position
  .position (Math.Translation) >= .transform
  (GFX.glTF :Path "../../../shards-pbr-demo/assets/mascot.glb"
            :Transform .transform
            :AnimationController
            (->
             (| (Setup
                 (ForEach (-> (Take 0) >> .animation-names))
                 .animation-names
                 (RandomFloat 5.0) = .animation-offset)
                .animation-names (Take .animation-index) >= .animation-name)
             (Take .animation-name) >= .animation

             (Animation.Timer .animation :Rate 1.3 :Offset .animation-offset
                              :Action (->
                                       (Count .animation-names) >= .num-animations
                                       (Math.Inc .animation-index)
                                       .animation-index (Math.Mod .num-animations) > .animation-index
                                      ;;  (Log "Playing next animation");
                                       ))
             (Animation.Play .animation);
             ))>= .gltf
  .gltf (GFX.Draw .queue))

(defwire spawn-benchmark
  (Log "Spawning models")
  8 >= .num-x (ToFloat) (Math.Divide 2.0) >= .sub-x
  8 >= .num-y (ToFloat) (Math.Divide 2.0) >= .sub-y
  
  (ForRange 1 .num-y
            (->
             (ToFloat) (Math.Subtract .sub-x) >= .x
             (ForRange 1 .num-x
                       (->
                        (ToFloat) (Math.Subtract .sub-y) >= .y
                        (Float3 .x 0.0 .y) >= .position
                        {:Position .position} (Spawn character))))))


(defloop test-basic-anim
  (Setup
   (Float3 0 0 0) (Math.Translation) >= .t1

   "" >> .animation-names
   (Clear .animation-names)
   1 >= .animation-index

   (GFX.DrawQueue) >= .queue

  ;; Render steps
   (GFX.BuiltinFeature :Id BuiltinFeatureId.Transform) >> .features
   (GFX.BuiltinFeature :Id BuiltinFeatureId.BaseColor) >> .features
   {:Features .features :Queue .queue} (GFX.DrawablePass) >> .render-steps

  ;; Create view
   (get-view-transform 0.0) >= .view-transform
   (GFX.View :View .view-transform) >= .view)

  (GFX.MainWindow
   :Title "glTF" :Width 1280 :Height 720 :Debug false
   :Contents
   (->
    (Animation.Timer :Rate 0.2 :Offset -0.75) >= .time
    (get-view-transform .time) > .view-transform
    ;; (GFX.glTF :Path "../shards/external/glTF-Sample-Models/2.0/AnimatedCube/glTF/AnimatedCube.gltf") (GFX.Draw)
    ;; (GFX.glTF :Path "../shards/external/glTF-Sample-Models/2.0/BoomBoxWithAxes/glTF/BoomBoxWithAxes.gltf") (GFX.Draw)
    ;; (GFX.glTF :Path "../shards/external/glTF-Sample-Models/2.0/MultiUVTest/glTF-Binary/MultiUVTest.glb") (GFX.Draw)
    .queue (GFX.ClearQueue)
    (Branch [spawn-benchmark])

    (GFX.Render :Steps .render-steps :View .view))))
(schedule root test-basic-anim)
(if (run root timestep) nil (throw "Root tick failed"))
